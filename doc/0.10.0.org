* DONE build engine packages: engine basic + create scene package + render scene package + whole engine package(use first twos)


** DONE scene package:
api
init, update jobs

transform, camera, gameObject

add other apis


pass compile


** DONE refactor: rename extensionName to extensionProtocolName

meta3d-package
meta3d



** DONE engine basic package:
register work plugin root
register extensions:
engine basic, engine core, most, immutable? extension

engineCoreState = setIsDebug(engineCoreState, isDebug)





** DONE render package:
api
init(material, geometry), update jobs

accept canvas





use webgl, no worker
# use webgpu





** DONE whole engine package has create scene, render api:
api:
    init,update,render
    scene api:
        encapsulate to engine core state, service to meta3d state;

init:
invoke three packages' init;
engineCoreState = engineCoreService.init(engineCoreState, meta3dState)
run init pipeline

update:
run update pipeline

render:
run render pipeline




* DONE download whole engine package to use as a engine to draw a cube

engine whole package:
engine core, immutable, most
packages




engine basic package:
register extensions:
# engine basic, engine core, most, immutable? extension
engine basic

root





engine render package:
register extensions:
webgl1, ...


# ** TODO feat(default): meta3d: if not has entry extension, error with info

** DONE fix(default): meta3d: loadPackage should get current package's entry extensionProtocolName

////should store package's entry extensionProtocolName when build package!


** DONE pass empty gameObject run test

# init

# loop








** DONE pass cube run test

add to RenderJob:
clearColor
clear
////diable depth

TODO repack scene,render,whole packages



# * TODO add edit view control implement by FBO
* TODO add view control implement(low level) for scene view by FBO

# provide init life handle

# can use to build scene view, game view high level custom controls



# one canvas-one view-one gl




# one canvas-one view-one gl-one engine state(meta3dState?)(encapsulate), contain scene view and game view

pro:
share textures

# encapsulate viewport logic


# config:
# viewRect

#   |> DeviceManagerEngineService.setViewport(viewRect)
#   |> DeviceManagerEngineService.setScissorTest(true)
#   |> DeviceManagerEngineService.setScissor(viewRect)





# add extension:
# engineForEditor
#     has engine state

# invoke engine api by engine whole package


directly use engine-whole package?
engine state is engineCoreState in meta3dState








add work-plugin for editor
scene-view

init jobs

job1:
create and init each fbo's texture
set texture to textureId in ui state. map

(uiService add getIMGUICurrentContext)


job2:
add default gameObjects(one cube gameObject, one camera gameObject) to engine state and editorState->sceneView




# update jobs

render jobs:
job1: 
viewport
setScissor test
bindFramebuffer
clear
render scene view, game view to each fbo's texture
unbindFramebuffer


register in use-editor extension


use-editor extension:
_loop:
invoke work plugin's update, render before uiService.render(so can generate view texture before)

init:
invoke work plugin's init after uiService.init(so can get imgui context after)








canvas?


            # {
            #     rect,
            #     canvasId,
            #     # no children
            # }


# specific data:
# {
#         name: "canvasId",
#         type_: "string",
#         value: _generateUniqueId()
#     }


# ui component
as ui control:
View

window    ////(bar:Scene View)
children:
Image: 
get texture by uiService.getViewTexture(meta3dState, textureId) from meta3dState
# (if texture not exist(when in element assemble space), get default texture)
(if texture not exist(when in element assemble space), get null)


            {
                rect,
                label,
                textureId,
                # no children
            }


specific data:
{
        name: "label",
        type_: "string",
        # user change to Scene View
        value: "View"
    }
{
        name: "textureID",
        type_: "string",
        # value: _generateUniqueId()

        # TODO need user give:sceneView
        value: ""
    }





** DONE finish UIManager

# TODO pass compile
# TODO pass test

add test cases


** DONE finish view control

** DONE work plugin->execFunc should get meta3dState and return stream<meta3dState>

# TODO pass work plugin compile:
creategl
render,
...


** TODO finish work plugins

TODO finis meta3d-work-plugin-editor-webgl1-scene-view


** TODO update use-editor extension




** TODO run test


*** TODO rebuild engine whole package


*** TODO pass engine whole package run test

*** TODO pass view run test


* TODO refactor: rename DepenentMapType -> ExtensionName, ContributeName to ExtensionProtolName, ContributeProtocolName

* TODO refactor: rename work plugin -> ExtensionName, ContributeName to ExtensionProtolName, ContributeProtocolName
e.g.  let {
		meta3dWebgl1ExtensionName,
		meta3dBsMostExtensionName,
		meta3dUIExtensionName,
	} = dependentMapData[0]



* TODO refactor: work plugin webgl1 state: remove   workPluginWhichHasAllRenderComponentsName, ..., use protocol name instead



* TODO handle event

** TODO camera gameObject add arcball component


** TODO handle event




* TODO run test: add scene view based to show a cube + arcball camera


# * TODO run test: add scene view based on 3D view to show a cube + arcball camera + grid
* TODO run test: add grid



* TODO use view control implement(low level) for scene view and game view

one canvas-one view-one gl

one engine state(meta3dState?)(encapsulate)


contain scene view and game view



** TODO add meshrenderer component

has isRender

** TODO update PrepareRenderDataJob


** TODO render scene view and game view

share gl, engine state


encapsulate viewport logic


config:
viewRect

  |> DeviceManagerEngineService.setViewport(viewRect)
  |> DeviceManagerEngineService.setScissorTest(true)
  |> DeviceManagerEngineService.setScissor(viewRect)




scene view has default scene gameObjects




* TODO handle event

** TODO handle scene view, game view event

refer to wonder-editor code

add event target


dependent on scene view event, game view event(has independent state)?



* TODO run test: add scene view, game view based to show a cube + arcball camera + grid





* TODO add two buttons, to add a cube gameObject and add a arcball camera controller gameObject


* TODO add run button to run game view


# * TODO refactor: extract 3D View custom control(low level)







* TODO refactor: remove unused extensions, contributes, related protocols

* TODO refactor: rename getGL to getGl??

* TODO publish
