* DONE build engine packages: engine basic + create scene package + render scene package + whole engine package(use first twos)


** DONE scene package:
api
init, update jobs

transform, camera, gameObject

add other apis


pass compile


** DONE refactor: rename extensionName to extensionProtocolName

meta3d-package
meta3d



** DONE engine basic package:
register work plugin root
register extensions:
engine basic, engine core, most, immutable? extension

engineCoreState = setIsDebug(engineCoreState, isDebug)





** DONE render package:
api
init(material, geometry), update jobs

accept canvas





use webgl, no worker
# use webgpu





** DONE whole engine package has create scene, render api:
api:
    init,update,render
    scene api:
        encapsulate to engine core state, service to meta3d state;

init:
invoke three packages' init;
engineCoreState = engineCoreService.init(engineCoreState, meta3dState)
run init pipeline

update:
run update pipeline

render:
run render pipeline




* DONE download whole engine package to use as a engine to draw a cube

engine whole package:
engine core, immutable, most
packages




engine basic package:
register extensions:
# engine basic, engine core, most, immutable? extension
engine basic

root





engine render package:
register extensions:
webgl1, ...


# ** TODO feat(default): meta3d: if not has entry extension, error with info

** DONE fix(default): meta3d: loadPackage should get current package's entry extensionProtocolName

////should store package's entry extensionProtocolName when build package!


** DONE pass empty gameObject run test

# init

# loop








** DONE pass cube run test

add to RenderJob:
clearColor
clear
////diable depth

TODO repack scene,render,whole packages



# * TODO add edit view control implement by FBO
* TODO add view control implement(low level) for scene view by FBO

# provide init life handle

# can use to build scene view, game view high level custom controls



# one canvas-one view-one gl




# one canvas-one view-one gl-one engine state(meta3dState?)(encapsulate), contain scene view and game view

pro:
share textures

# encapsulate viewport logic


# config:
# viewRect

#   |> DeviceManagerEngineService.setViewport(viewRect)
#   |> DeviceManagerEngineService.setScissorTest(true)
#   |> DeviceManagerEngineService.setScissor(viewRect)





# add extension:
# engineForEditor
#     has engine state

# invoke engine api by engine whole package


directly use engine-whole package?
engine state is engineCoreState in meta3dState








add work-plugin for editor
scene-view

init jobs

job1:
create and init each fbo's texture
set texture to textureId in ui state. map

(uiService add getContext)


job2:
add default gameObjects(one cube gameObject, one camera gameObject) to engine state and editorState->sceneView




# update jobs

render jobs:
job1: 
viewport
setScissor test
bindFramebuffer
clear
render scene view, game view to each fbo's texture
unbindFramebuffer


register in use-editor extension


use-editor extension:
_loop:
invoke work plugin's update, render before uiService.render(so can generate view texture before)

init:
invoke work plugin's init after uiService.init(so can get imgui context after)








canvas?


            # {
            #     rect,
            #     canvasId,
            #     # no children
            # }


# specific data:
# {
#         name: "canvasId",
#         type_: "string",
#         value: _generateUniqueId()
#     }


# ui component
as ui control:
View

window    ////(bar:Scene View)
children:
Image: 
get texture by uiService.getViewTexture(meta3dState, textureId) from meta3dState
# (if texture not exist(when in element assemble space), get default texture)
(if texture not exist(when in element assemble space), get null)


            {
                rect,
                label,
                textureId,
                # no children
            }


specific data:
{
        name: "label",
        type_: "string",
        # user change to Scene View
        value: "View"
    }
{
        name: "textureID",
        type_: "string",
        # value: _generateUniqueId()

        # TODO need user give:sceneView
        value: ""
    }





** DONE finish UIManager

# TODO pass compile
# TODO pass test

add test cases


** DONE finish view control

** DONE work plugin->execFunc should get meta3dState and return stream<meta3dState>

# TODO pass work plugin compile:
creategl
render,
...


** DONE finish work plugins

TODO finis meta3d-work-plugin-editor-webgl1-scene-view


add work-plugin for editor
scene-view

init jobs

job1:
create and init each fbo's texture
set texture to textureId in ui state. map


# job2:
add default gameObjects(one cube gameObject, one camera gameObject) to engine state and editorState->sceneView




update jobs:
job1:
update engine


  |> DeviceManagerEngineService.setViewport(viewRect)
  |> DeviceManagerEngineService.setScissorTest(true)
  |> DeviceManagerEngineService.setScissor(viewRect)

render jobs:
job1: 
viewport
setScissor test
bindFramebuffer
clear
render scene view, game view to each fbo's texture
unbindFramebuffer



** TODO edit ui control


# # *** TODO getContribute return add data

# # equal to rect + specific data

# # data should be build the same as build rect and specific data




# # # so can get viewRect by getUIControlFunc()(null, [{}, {}]).data.rect!
# # so can get viewRect by getUIControlData(meta3dState, "SceneView").rect!


# # TODO update ElementMRUtils

# # TODO update ui controls



# # # *** TODO remove scene-view ->inputData->textureID, move it to contributeData

# # *** DONE uiControlContribute add controlData type




# *** TODO update ui


# add prepare for invoke ui control's createState



# remove old data, set new data


# add getUIControlState

# update meta3d type


# add test cases




# *** TODO can edit uiControlName in UIControlInspector


# TODO update rect, specific


# TODO update ElementMRUtils

# invoke getUIControlState



# TODO update UIControlInspector



# *** TODO update ui controls and protocol->Config and meta3d

# meta3d:
# add removeUIControlContribute
# remove config ->...








*** DONE 


# TODO ui remove updateUIConname,prepare,uiControlStateMap

# TODO ui update by get from elementFuncMap[0]
# (check elementFuncMap.length === 1)



# TODO move uiControlName to ui control protocol->Index
# not has unique id


# TODO not edit uiControlName, use SceneView ui control instead
# remove textureID from specific


# TODO elementContribute add uiControlStates data

////TODO update element protocol 





/*
TODO Config add :
export let getUIControlState: getUIControlStateMeta3D = (rect, specific) => {
  return {
    rect: rect
  }
}

  TODO should define specific type in Index

    TODO type inputData = {
      rect:rect,
      ...specific
    }
  */





////TODO ElementMRUtils generate  uiControlStates

////if uiControlName exist, not set again


////TODO update meta3d, add getUIControlState





# TODO update ui

# add setUIControlState

# update getUIControlState from ui state



# TODO update view

# setUIControlState in func 



# TODO update meta3d-work-plugin-editor-webgl1-scene-view

# add UpdateJob

# update other



# TODO update all ui controls


** DONE fix engine-render: remove creategl?



** DONE update use-editor extension





use-editor extension:
_loop:
invoke work plugin's update, render after uiService.render
# (so can generate view texture before)
(so can get view rect)

init:
register editor work plugin
how to get viewRect?

  get viewRect


# prepare
# should invoke ui.prepare



invoke engineWhole.prepare, work plugin's init after uiService.init(so can get imgui context after)




TODO refactor

** DONE separate engine whole package between editor and engine

work-plugin-camera not dependent on meta3d-ui?

on -data


-data:
add GetViewRectJob in update pipeline




update data, camera

editor -> engine use own creategl, data 




refactor: add gl to data; get gl from data




TODO different engine-render, engine-whole package
  # engine-render, engine-whole extension not change
  engine-whole extension not change
  engine-render extension change




TODO update use-editor




** TODO refactor: work plugin webgl1 state: remove   workPluginWhichHasAllRenderComponentsName, ..., use protocol name instead



** TODO refactor: rename DepenentMapType -> ExtensionName, ContributeName to ExtensionProtolName, ContributeProtocolName

** TODO refactor: rename work plugin -> ExtensionName, ContributeName to ExtensionProtolName, ContributeProtocolName
e.g.  let {
		meta3dWebgl1ExtensionName,
		meta3dBsMostExtensionName,
		meta3dUIExtensionName,
	} = dependentMapData[0]



** TODO rename work plugin to meta3d-engine-pipeline,meta3d-engine-pipeline-engine,meta3d-engine-pipeline-editor






** TODO run test

*** TODO update use-package2


*** TODO rebuild engine whole package for engine

publish


*** TODO pass engine whole package run test





*** TODO rebuild engine whole package for editor

not has meta3d-ui extension!


*** TODO pass view run test

TODO element->run


TODO published app



* TODO handle event

** TODO camera gameObject add arcball component


** TODO handle event




* TODO run test: add scene view based to show a cube + arcball camera


# * TODO run test: add scene view based on 3D view to show a cube + arcball camera + grid
* TODO run test: add grid



* TODO use view control implement(low level) for scene view and game view

one canvas-one view-one gl

one engine state(meta3dState?)(encapsulate)


contain scene view and game view



** TODO add meshrenderer component

has isRender

** TODO update PrepareRenderDataJob


** TODO render scene view and game view

share gl, engine state


encapsulate viewport logic


config:
viewRect

  |> DeviceManagerEngineService.setViewport(viewRect)
  |> DeviceManagerEngineService.setScissorTest(true)
  |> DeviceManagerEngineService.setScissor(viewRect)




scene view has default scene gameObjects



* TODO refactor: extract work-plugin-editor-view-utils




* TODO handle event

** TODO handle scene view, game view event

refer to wonder-editor code

add event target


dependent on scene view event, game view event(has independent state)?



* TODO run test: add scene view, game view based to show a cube + arcball camera + grid





* TODO add two buttons, to add a cube gameObject and add a arcball camera controller gameObject


* TODO add run button to run game view


# * TODO refactor: extract 3D View custom control(low level)







* TODO refactor: remove unused extensions, contributes, related protocols


* TODO refactor: rename getGL to getGl??

* TODO publish
