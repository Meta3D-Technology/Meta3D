* TODO refactor: 低代码抽象


** architecture


first level abstract:
uiControlInput+action+ui control(they are contribute???)

+two package(
engine for publish package
engine for editor package
)


second level abstract:
each of the two package = multiple packages


third level abstract:
each package = extensions + contributes(no package)


note: upper level not know down level!






ap assemble/engine package assemble(package level has dependency)/single package assemble(current dependency except pacakge dependent)/element assemble


** ui control

data:
    input:
    - input data(from engine, action)
    handle by uiControlInput
    - config data
    set in element assemble
    output:
    - data pass to action
    e.g. selected Menu Item text, is button clicked, ...
    TODO not trigger in protocol!



split inspector to multiple ui controls(e.g. Input3Float, Text, InputText, CollapsingHeader)

abstract SceneTree's Tree to Tree ui control




api = {
    editorWholePackage service(actually engine-whole-protocol),
}



** action

protocol is ui control's output data type protocol

name defined in implement

action: (meta3dState, api, inputDataFromUIControl) => Promise<meta3dState>
    forward
    backward

api = {
    # getEnginePackage(whole for editor) (meta3dState) => package service,
    # getEngineWholePackage (meta3dState) => package service(actually engine-whole-protocol),
    editorWholePackage service,

    get/setActionState(for all actions' states),

    operate events(e.g. setNeedReplaceAllEvents),

    trigger(
        can trigger other actions
        
        e.g. trigger publish action when select publish menu item!
        ),
}



action come from:
1.market(publish to)
2.input by textarea
# stored in event data
stored in editor file


** uiControlInput

protocol is ui control's input data type protocol

name defined in implement

uiControlInput: (meta3dState, api) => Promise<ui control's input data>

api = {
    editorWholePackage service,

    get/setActionState(for all actions' states),
}



uiControlInput come from:
1.market(publish to)
2.input by textarea
# stored in event data
stored in editor file

** two packages

package role:
whole for editor
whole for web


each of the two package = multiple packages(other role, e.g. render, scene, post pass, asset)



the two package has dependency, check in engine package assemble



package's protocol is package role(whole for editor/whole for publish)




# ** TODO demo1: ui control: Scene Tree(header+Tree)
** TODO demo1: ui control: Controller




*** TODO package assemble

TODO unify scene,game view
    # TODO api add createGameObjectForScene/GameView, getAllGameObjectsForScene/GameView
    TODO both view share the same state(same Scene Package), but different active camera, so game view only need re-render with different active camera by another Render Package


TODO unify whole for editor, engine protocol

package protocols:
meta3d-engine-whole-protocol
meta3d-editor-whole-protocol
meta3d-engine-scene/scene view render/game view render/web render/asset/ui/event-protocol
core-protocol
    core,root,most
    init: register root pipeline


TODO each package should get each data through package service:
    shouldn't directly get each data through pipeline!
        but can get self data through pipeline!

TODO new api: getPackageService(protocol)=>nullable<package service>

# two kind render package implement:
# SceneViewThreeRender
# GameViewThreeRender

one editor whole package implement = Scene + SceneViewThreeRender(new api: createSpecificDefaultGameObjects) + GameViewThreeRender + Asset

SceneViewThreeRender->render:
set arcball to active->render->restore active cameraView

GameViewThreeRender->render:
render directly with active cameraView

# engine whole editor implement:
editor whole implement:
create default scene(one active cameraView) and invoke SceneViewThreeRender's createSpecificDefaultGameObjects
new api: addToInitFuncs, addToUpdateFuncs, addToRenderFuncs(for run action; flags: isOnlyOnce)
    //so only packages dependent on whole! whole not know packages!
    # in life handle->init: invoke scene, scene view render, ui, event, basic to register funcs
    invoke scene, scene view render, ui, event, basic
new api: getPluggablePackageService(protocol)=>nullable<package service>


TODO remove run extension
# triggerViewDirty
# triggerRun
# registerEventHandler?
if(stop){
    getPluggablePackageService(protocol)->nullable<package service>->renderOnce
}


TODO extension,contribute not know action state





one engine whole package implement = Scene  + WebThreeRender + Asset




TODO refactor file structure???
add packages/:
xxx_packages/
    extensions/
    contributes/
    protocols/
        extensions/
        contributes


TODO packages + actions(contributes) + uiControls(contributes) + uiControlInputs(contributes)





# **** TODO run test: visual, visual run, run app with only editor-whole pacakge
**** DONE run test: visual with only editor-whole pacakge




**** TODO run test: Scene View

TODO add engine-scene, core

TODO add ui, event

TODO add scene view render
    TODO add entry implement
    TODO remove viewrect pipeline
    TODO move convertscenegraph job before render
    TODO merge pipeline
    TODO fix bind arcball event: bind for each view render!
    TODO set viewrect related before render
    TODO set arcball to active->render->restore active cameraView

    TODO pass compile






TODO add ui control




TODO core add entry implement, protocol
    TODO update engine-scene
    TODO update Job
    TODO update sceneview render->root pipeline(move root pipeline type to StateType)

TODO event add entry implement, protocol

TODO refactor get engine core, most, root:use getPackageService("meta3d-core-protocol"):
    add core implement
TODO refactor get engine scene:use getPackageService
TODO refactor get ui:use getPackageService
TODO refactor get event:use getPackageService

TODO refactor get editor whole:use getPackageService
e.g. scenegraph utils-> api.getExtensionService<editorWholeService>(meta3dState, editorWholeProtocolName) 






TODO update UpdateCameraJob
    TODO update meta3d-view-utils->getViewRect



TODO fix scene:remove unUsed
    TODO create gameObject: not consider un used





TODO update editor-whole




TODO publish all


TODO pass run test:
visual
visualRun
runApp


# **** TODO run test: SceneTree+Scene View+ *Game View
**** TODO run test: Controller+Scene View

**** TODO run test: Controller+Scene View+ *Game View

TODO extract Three Render Package from Editor Whole Package for both Editor/Engine Whole Package


**** TODO run test: publish(Button)


# **** TODO ap assemble:
# remove extension, contribute, only remain package



**** TODO fix: import app/package should keep package structure(sub, subsub, ... packages)



**** TODO fix: auto upgrade: upgrade saved/not saved in app packages(not upgrade their extensions/contributes)





*** TODO ui control

UI Control Inspector:
Rect, Config(old: Specific), Input, Event

TODO remove IsDraw

TODO Event is read from ui control output data:
    TODO remove Config.ts->getUIControlSupportedEventNames, generateHandleUIControlEventStr




TODO only get engine whole service




*** TODO action


TODO only get engine whole service

*** TODO ui control input


TODO only get engine whole service



*** TODO run test




# *** TODO feat: support published element contribute as a new UI Control(higher level)
# dependency:
# used ui control protocols
# used ui control input protocols
# used action protocols

# use case:
# 1.user publish element contribute as TransformInspector(=some InputFloat3 + ...) in element assemble
# 2.user select TransformInspector from Market, use it as a new ui control


# TODO add UIControl assemble


# TODO Scene Tree is published element contribute which = header window + Tree

*** TODO support import multiple element contributes
TODO check their used ui controls should be selected
TODO their element contribute protocol can be different
TODO just merge their Selected UI Controls


TODO Scene Tree = header window + Tree



TODO because element contribute dependent on uiControlInput and Action, dependency check should check them! 






** TODO demo2: ui control: Scene Tree(header+Tree)+Inspector(GameObject Inspector which only has a name)





** TODO demo3: ui control: Scene Tree(header+Tree)+Inspector(GameObject Inspector which only has a name)+Scene View+Game View




** TODO finish other



# ** TODO remove unused ones

# e.g. xxx-sceneview/gameview


** TODO two kind asset package implement:
BasicAsset
DracoKTX2Asset





* TODO UI Control可配置化、抽象化


** TODO Inspector
TODO split inspector to multiple ui controls(e.g. Input3Float, Text, InputText, CollapsingHeader)


TODO can make inspector show in element visual:
    by set uiControlInput to return true



split to Inspector(as container) + multiple Component Inspectors(as member)



Inspector: can edit component;set component's data;
TODO 加入更多的Component Inspector


*** TODO active basic camera view
TODO fix import scene* TODO>active

*** TODO add component
**** TODO now only add arcball, basiccameraview, perspective component, no other components
handle event
   **** TODO export/import scene/single event: use plugin for GLTFExporter, GLTFLoader to support arcballCameraController
   **** TODO publish: bind event when active has arcball



** TODO Menu
Menu->Specific: set Array<Array<name:string, actionName:string>>

** TODO SceneTree
separate header, body:
    header = multiple Image Buttons

** TODO Asset
separate header, body:
    header = multiple Image Buttons

** TODO Controller
abstract to Switch Button with configable two textures


# ** TODO Message


# ** TODO Model


















* TODO 构建三个示例场景

1.Engine + Example use Engine package
2.Editor
3.Scene use Editor to build and publish


** TODO build one big scene with glbs as showcase

3D场景漫游

** TODO pass run test:publish
TODO update engine package