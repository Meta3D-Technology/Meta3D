* DONE finish design

extension type:
common
entry

contribute type:
ui control
skin
element
action
component
work plugin


** step

# 1 in ap view: select extensions, contributes include control expect entry extension only once - global share
1 in ap view: select common extensions, ui control, skin, action, component, work plugin contributes only once - global share

for all elements

2 switch to ui view

3 decide canvas

4 finish and publish element contribute

onRegister:
add self to meta3dState

so can be registered in editor entry extension one by one


5 switch to ap view

6 select multiple published element contributes

7 select one entry extension

8 publish



* DONE rename event contribute to action contribute
rename eventName to actionName


* DONE rename custom control contribute to ui control contribute



* DONE contribute add type field

contribute type:
ui control
skin
element
action
component
work plugin


meta3d:
api add getAllContributesByType

# * TODO ap view: select common extensions, ui control, skin, action, component, work plugin contributes only once - global share


# share for all elements


# api add getAllContributesByType



# common extensions get by filter by getExtensionLife -> onStart not exist)



* DONE ap view

** DONE middle: define all canvas


# ui view has a global canvas
ui view can has multiple global canvas


add components:
CanvasController
View

store->View add canvas

action: canvas z-index, width, height



# global size

# should render all canvas with white background color


# default background color is black


** DONE middle-top: create canvas config

can specify canvas's absolute position, width, height, z-index

overflow: scroll



add to store


** DONE add canvas dom
background color: white
add boarder



# element with different canvas' size


** DONE bdd test

** DONE refactor: feature->prepare to prepare, not expose sandbox, snapshot!

** DONE run test

test canvas dom


* TODO add UI视图

visual element func

** goal:  remove element contribute code, all generated by json!




** DONE components: ap_view/

apViewState

run test:
should reset

** DONE add ui view

add ui view switch button

run test

*** DONE fix reset

apView, uiView add bdd test



** DONE left: UI Control Contributes, Selected UI Control Contributes

show by select control one by one


TODO get by type from selectedExtensions



** DONE bdd test

# contributes





** DONE run test


** DONE middle-top: select used canvas

# render used canvas

# should render all canvas with white background color


# default background color is black

with border


** DONE bdd test


** DONE move canvas controller to ap view, ui view use it

so application can use it when be published

** DONE start default run to draw selected canvas

implement by rescript


use the selected canvas


with shared registered;

register current element contribute(with fake one)
(javascript->webpack result)
(draw one button)
to ui view->store

# only register this element:
# json -> element contribute:
# change -> json -> generate element contribute and replace old one

not register action;
not bind event;


*** DONE extension life add onInit, onUpdate


*** TODO run


*** TODO ui view: add ui view visual

# *** TODO register default element

*** TODO invoke onInit when init

e.g. change canvas data

*** TODO invoke onUpdate when need update

# e.g. change canvas data, select ui control
e.g. change canvas data

invoke update function



** DONE bdd test UIVisual


** DONE run test

publish protocol, extension

run test


# TODO fix: not error message


# ** TODO can drag button(ui control) to canvas

** DONE fix: init once

** DONE fix: handle when change canvas data

** DONE fix: loading

** TODO click button(ui control), add to canvas

in default rect

*** DONE update "start default run" to draw view


test with test generated element code

click 

add action:
InitVisual
UpdateVisual


***  DONE pass bdd test

***  DONE pass run test

# fix Main: use getAllContributesByType for skin, ui control


# Main not update?




*** DONE generate mr


json -> generate element contribute code(javascript)

ui control protocol should define json related meta data?

***  DONE pass bdd test



# *** TODO update "start default run" to draw view


# only register this element:
# json -> element contribute:
# change -> json -> generate element contribute and replace old one



# ***  TODO pass bdd test

***  DONE pass run test

update and publish meta3d-ui-view-element-protocol version
let _getElementContributeProtocolVersion = () => "0.5.0"

# *** TODO refactor: add contract check

# *** TODO refactor: move to ap layer

** DONE rect

*** DONE control add properies

selectedUIControlInspectorData


rect:
x y width height


** TODO event and reducer

*** DONE control add event


# ui view store:
# add selectedActions


UIControlInspector:
judge protocol name, version to show event(e.g. button only has click event)
["click", ...]

    then select action name
        # judge action's protocol name, version to show action data input
        no action data(use null)



ElementMR:
judge protocol name, version to build trigger event code



event:

click,
    focus,
...



click:
list(action name) by select action contributes




# visual extension:
# register event



*** DONE bdd test

inspector

element mr

*** DONE run test

key




*** TODO reducer

**** DONE add ElementInspector


**** DONE add ElementController


**** DONE add elementState

custom data:
list:
    field name, field type(select: string, number), field default value



# fix:
# type select
# type miss

# reset



**** DONE ElementMR


**** DONE bdd test

# test dispatch -> reducer -> update view

**** DONE run test

**** DONE ui control protocol define data which can be send and get in assemble-space!  

**** DONE refactor HandleUIControlProtocolUtils: invoke protocol's handler data instead of judge protocol name!


**** DONE pass bdd test

need test:
# publish tool
# backend-cloudbase
assemble-space:
    # Contributes
    # UIControls
    # ElementMRUtils




**** DONE pass run test


# **** TODO implement publish element


**** DONE move actions to action's protocol

publish;
protocol can be send and get in assemble-space!  


**** DONE rewrite action contribute




return {
    ...,
    stateAction:
    # {
    #     "changeText": {
    #         role: "secondButton",
    #         /value?
    #     }
    # },

    [
        {
            name: "changeText",
            // target:""
            role: "secondButton",
            // value: Math.random().toString()
        }
    ],


    # handler: (meta3dState, stateAction, eventData) => {
    handler: (actionAPI, meta3dState, eventData) => {
        uiState = dispatch(uiState,
            //     uiService.buildStateAction(
            //     {
            //         name: "changeText",
            //         // target:""
            //         role: "secondButton",
            //         value: Math.random().toString()
            //     }
            // )

            actionAPI.buildAction<valueType>({
                name: "changeText",
                value: (oldValue) => Math.random()
            })
    },
    ...
}
)


**** DONE element add reducers

role(string):
list by select action contributes;
// can add custom role

handler:
// "changeText": { role: "secondButton" }

list by stateAction names from select action contributes
    -> select state field(e.g.text)
        directly update it
// -> ( value, oldValue) => newValue
update it!





**** DONE update ui->init
get all elements' protocol data

combine self->reducers to uiState

# so can be combined in editor entry extension 



**** DONE update UIManager->dispatch

*** DONE pass compile

*** DONE bdd test

////mainly test:
dispatch to invoke reducer!


need test: 
# ElementInspector
# UIVisual
# ElementMR
# ui->UIManager->init, dispatch

*** DONE run test(without run visual)


# ElementInspector -> Role bug?

role: empty

update: no select



fix: 
        SelectUtils.isEmptySelectOptionValue(actionName) ||

show style:inline




publish:
# action
# action protocol
//view extension
# ui
# ui protocol



*** DONE feat: ui view->run in new tab

use new visual extension:


register action

bind event

loop

//update mr


*** DONE bdd test


*** DONE run test

run test with run visual

publish:
run visual extension, protocol



fix:
indexdb

action name

submit not update

event

string type convert

mr



pass bdd test:



# *** TODO feat: remove onStart, startApp



** DONE refactor: remove version, get newest version

# add getAllPublishNewestExtensions

# implement add name




# bdd test

# run test


** DONE add contract check: name should unique

** DONE rename

** DONE publish element contribute(to replace element-button, element-button2) to user's Element Contributes

*** DONE implement

send to server


# onRegister:
# add self to meta3dState

# so can be registered in editor entry extension one by one

# editor entry extension can get them by api.getAllContributesByType 





# should publish element protocol
# protocol has:
# element state
# reducer


should publish element assemble data:
username(publisher)


element:
    element state
    reducer
uiControls:
    array<{
name,

rect,
event
    }>


    username: string,
    elementName: string,
    elementVersion: string,
    inspectorData: {
        element: {
            elementState: any,
            reducer: any
        },
        uiControls: Array<{
            name: string,
            rect: any,
            event: any
        }>
    }

element assemble can generate by them:
selectedUIControls
selectedUIControlInspectorData
elementInspectorData



provide when publish:
element name
element version
# element protocol name
# element protocol version


all elements use the same element protocol!
(not define elementName in protocol!)


# *** TODO should generate element contribute and protocol config data

# *** TODO add reducer, element state(with default value) to element's protocol config and element contribute!
# publish;
# protocol can be send and get in assemble-space!  


# so can get reducer, element state from protocol when switch to ui view!



# TODO should generate element protocol config data


*** DONE pass compile

*** DONE bdd test

need test:
# register
//publisheleassda
//publishelecon
# backend->PublishElementContributeService

# PublishElement

*** DONE fix: fix element name for generate

*** DONE update protocol

TODO publish



*** DONE rename ui-view-visual to element-assemble-visual

TODO publish

*** DONE run test




** DONE feat: import single element

1.in ap view
2.select other
# 3.select one element(import element)
3.select one element (select contribute)
4.switch to ui view
5.can continue edit the element visually

*** DONE implement

if selectedContributes change,

check:should only select <=1 element!
and load element assemble data and set

if element assemble data change, update data by dispatch

# *** TODO update "so can get reducer, element state from protocol when switch to ui view!" logic: to the specific element instead of switch to ui view!
# *** TODO can get reducer and element state by parse to element->"getContribute"
*** DONE can get reducer and element state by element ui view data


ui view can generate by them:
selectedUIControls
selectedUIControlInspectorData
elementInspectorData


when switch to ui view, get element ui view data!


*** DONE check when switch to ui view: should only select <=1 element!



*** DONE pass compile


*** DONE bdd test


*** DONE run test

# should message error

# concat bug

# no FileID


# why not message modal?


# not found


# add one;
# switch;

# miss!


# TODO continue:
# select two elements->not show?


# select one element->add ->publish->select new: 'isClick' has already been declared


# why together?


# first switch not render?




** DONE refactor: test->feature->dispatch xxx action change to Xxx action

** TODO fix control properies


*** DONE rect add use element state

choose element field
empty
...


# add select(select field)(default is empty) + func input(
#      default value: (fieldValue) => fieldValue
# )


add func input(
     default value: function (elementState){
         return 0
     }
)

e.g. new value:
      function (elementState) {
          return elementState.x
      }



*** DONE bdd test

# need test:
# UIControlInspector
# ElementMR



*** DONE run test: test reducer to change rect when run


publish:
# ui control button protocol


*** TODO isDraw


# isShow: true/false

#     design for single element


# aselect(select field)(default is empty) + func input(
#      default value: (fieldValue) => true
# )


element: 
add bool type


func input(
     default value: function (elementState) {
         return true
     }
)


*** TODO skin

one skin to one ui control:
change meta3d-skin-default to meta3d-skin-ui-control-button

change to:
drawButton(rect, skin)

so button know use which skin protocol!


change: let { normal } = getSkin<skin>(state, skinName).skin.button

to: let { normal } = skin.button
            








# ** TODO bdd test








# ** TODO element add properties


# update json






# state:
# default is empty, decide by element properties



# # isShow: null / true / false
# #     (add isShow to state when not null)

# isShow: true / false
#     # (add isShow to state when not null)
#     mainly for multiple elements

# execOrder: input: 0

# # custom data:
# # field name, field type, field default value

# # (move wonder editor->script attribute here?)

# # * TODO feat: ui view->run in new tab

# # register action

# # bind event

# # loop



# * TODO feat: select other elements and edit new element

# ui view only show new element;
# when run, run together

# ** TODO run test

# test reducer for multiple elements when run



* TODO pass run test: single element

element contribute with two buttons:
one button
    when click the button, show the second button:
one button with different rect, color





* TODO ap view: pass publish run test


** TODO select element contribute

# get from server by user

- select from contribute shop

- select element contribute



** TODO remove element-button, element-button2 contributes



** TODO select entry extension when click publish button!

# type:
# editor(default )
# // engine(default)
# user
#     (user implement and publish)
#     (filter by getExtensionLife -> onStart exist)

# show:
# editor entry extension
# // engine entry extension
# user's entry extensions(user implement and publish)

(filter by getExtensionLife -> onStart exist)

e.g. still use use-editor!


(only use the newest selected one!)


    # (engine should be extend package in the future)



note: remove entry extension step!!!


# ** TODO editor default extension

# create and insert canvas with global size;





# * TODO test(assemble-space): add bdd test



# * TODO feat: import mutliple elements

# 1.in ap view
# 2.select other
# 3.select two elements(import element)
# 4.switch to ui view
# 5.can continue edit the two elements visually



# * TODO pass run test: two elements

# first element contribute:
# one button


# when click the button, show second element contribute:
# one button with different rect, color




# * TODO control add 

# properies:

# rect:
# x y width height



# isShow: true/false

#     design for single element




# event:

# click,
#     focus,
# ...



# click:
# list(action name) by select action contributes



# styles:

# skin






# properties->input data
# rect
# (input data->rect need add "property" flag?)

# styles->skin
# (add to input data and add "style" flag?)

# events->click event(add more event in the future)
# (read events from protocol->event data?)







# * TODO pass run test: single element

# element contribute with two buttons:
# one button
#     when click the button, show second element contribute:
# one button with different rect, color







# * TODO ap view: select common extensions, ui control, skin, action, component, work plugin contributes only once - global share


# share for all elements





# common extensions get by filter by getExtensionLife -> onStart not exist)




* DONE refactor: rename UI视图 to Element视图; rename UIView to ElementView






* TODO publish






* TODO extend package space

与“装配空间”并列！

add bdd test

type:
engine
editor
custom(in the future)


** TODO assemble-space: select entry extension should provide default editor entry extension if register editor type extend package!